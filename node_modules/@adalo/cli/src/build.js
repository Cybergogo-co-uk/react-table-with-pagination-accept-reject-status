const fs = require('fs')
const ChildProcess = require('child_process')
const path = require('path')
const util = require('util')
const webpack = require('webpack')
const { filterObject } = require('./objects')

// Promisify
const readFile = util.promisify(fs.readFile)
const writeFile = util.promisify(fs.writeFile)
const stat = util.promisify(fs.stat)
const mkdir = util.promisify(fs.mkdir)
const exec = util.promisify(ChildProcess.exec)
const { defaultConfig } = require('./webpackConfig')

const { migrate } = require('./utils/migrate')

module.exports = async (args, opts) => {
  console.log('  Building Library....')

  const pkgPath = path.join(process.cwd(), 'package.json')
  const pkg = await loadJSON(pkgPath)
  const adaloConfigPath = path.join(process.cwd(), 'adalo.json')
  if (!fs.existsSync(adaloConfigPath)) {
    console.log(
      chalk.bold.yellow(
        '  New adalo.json does not exist, converting your project to use the new adalo.json...'
      )
    )
    console.log('')
    await migrate()
  }
  const adaloConfig = await loadJSON(adaloConfigPath)
  const { name, version } = pkg

  const config = { ...adaloConfig, name, version }

  console.log('')
  console.log(JSON.stringify(config, null, 2))
  console.log('')

  await mkdir('dist/input', { recursive: true })
  await mkdir('dist/icons', { recursive: true })
  let manifests = await getManifests(config.components)
  let webpackConfig = await getWebpackConfig(config)

  await buildEditorComponents(config, manifests, pkg.main, webpackConfig)
  await buildRuntimeComponents(config, manifests, pkg.main, webpackConfig)
  await buildMetadata(config, manifests)
  await copyLogo(config, { ignoreLogo: opts.ignoreLogo })
  await copyImages(config, manifests)

  console.log('\n')
}

const getManifests = async (components) => {
  let manifests = {}

  for (let component of components) {
    let manifestPath = component.manifest
    let manifest = await loadJSON(manifestPath)
    manifest.name = component.name

    if (manifests[manifestPath]) {
      throw new Error(`Multiple components cannot share the same manifest file.
        \nBOTH USING: ${manifestPath}\n`)
    }

    manifests[manifestPath] = manifest
  }

  return manifests
}

const getWebpackConfig = async (config) => {
  if (!config.webpackConfig) return defaultConfig
  let { webpackConfig: webpackConfigFile } = config
  let webpackPath = path.join(process.cwd(), webpackConfigFile)
  if (!fs.existsSync(webpackPath)) {
    throw new Error(
      `Webpack config is specified in package.json, but the file does not exist!\n` +
        `File path: ${webpackPath}\n\n`
    )
  }
  let { default: webpackConfig } = await import(webpackPath)
  if (!webpackConfig) webpackConfig = defaultConfig
  return webpackConfig
}

const buildEditorComponents = async (
  config,
  manifests,
  entryPoint,
  webpackConfig
) => {
  let index = {}
  let imports = []

  for (let configItem of config.components) {
    let { name } = configItem

    if (!name.match(/^[a-z_][a-z\d_]*$/i)) {
      throw new Error(
        `Invalid component name: ${name} (in ${manifestPath})\n\n` +
          '////////////////////////////////////////////////////////////////\n' +
          '//\n' +
          '//  Please use camelCase or snake_case for component names.\n' +
          '//\n' +
          '//  Names can contain letters, numbers, and underscores (_),\n' +
          '//  but cannot start with a number.\n' +
          '//\n' +
          '////////////////////////////////////////////////////////////////\n\n'
      )
    }

    if (name in index) {
      throw new Error(
        `Component names must be unique (${name} in ${manifestPath})`
      )
    }

    imports.push(name)
    index[name] = true
  }

  let file = 'import {\n  '
  file += imports.join(',\n  ')
  file += `\n} from '${path
    .join('../../', entryPoint)
    .replace(/\\/g, '/')}'\n\n`

  file += 'export const components = {\n  '
  file += imports.join(',\n  ')
  file += '\n}\n\n'
  file += `export const config = ${JSON.stringify(
    prepareConfig(config, manifests)
  )}`

  let inputFilename = './dist/input/editor.js'
  let outputFilename = './dist/editor.js'
  await writeFile(inputFilename, file)

  let libraryName = ['protonLibraries', config.name, config.version]
  await pack(libraryName, inputFilename, outputFilename, webpackConfig)
  console.log('  SUCCESSFULLY COMPILED EDITOR COMPONENTS.')
}

const buildRuntimeComponents = async (
  config,
  manifests,
  entryPoint,
  webpackConfig
) => {
  let imports = ['export {']

  for (let configItem of config.components) {
    let manifestPath = configItem.manifest
    let manifest = manifests[manifestPath]
    let importName = configItem.name

    // Expect this to be caught above.
    if (!manifest.name.match(/^[a-z_][a-z\d_]*$/i)) {
      throw new Error(`Invalid component name: ${manifest.name}`)
    }

    imports.push(`  ${importName} as ${manifest.name},`)
  }

  imports.push(
    `} from '${path.join('../../', entryPoint).replace(/\\/g, '/')}'`
  )
  let file = imports.join('  ')

  let inputFilename = './dist/input/runtime.js'
  let outputFilename = './dist/runtime.js'

  await writeFile(inputFilename, file)
  await pack(
    ['protonRuntime', config.name],
    inputFilename,
    outputFilename,
    webpackConfig
  )
  console.log('  SUCCESSFULLY COMPILED RUNTIME.')
}

const buildMetadata = async (config, manifests) => {
  let result = {}

  for (let configItem of config.components) {
    let { name } = configItem
    let manifest = manifests[configItem.manifest]

    result[name] = manifest
  }

  await writeFile('./dist/metadata.json', JSON.stringify(result))
  console.log('  SUCCESSFULLY COMPILED METADATA.')
}

const pack = (libraryPath, inputPath, outputPath, webpackConfig) => {
  let outputDir = path.dirname(outputPath)
  let outputFilename = path.basename(outputPath)
  let compiler
  compiler = webpack({
    ...webpackConfig,
    mode: 'production',
    entry: inputPath,
    output: {
      path: path.join(process.cwd(), outputDir),
      filename: outputFilename,
      library: libraryPath,
      libraryTarget: 'window',
    },
  })

  return new Promise((resolve, reject) => {
    compiler.run((err, stats) => {
      let info = stats.toJson()

      if (stats.hasErrors()) {
        console.error(...info.errors)

        process.exit(1)
      }

      if (stats.hasWarnings()) {
        console.warn(info.warnings)
      }

      return resolve(info)
    })
  })
}

const copyLogo = async (config, opts = {}) => {
  const { logo } = config
  const { ignoreLogo } = opts

  if (ignoreLogo) return

  if (!logo) {
    throw new Error('Missing Library Logo')
  }

  if (!logo.match(/\.png$/)) {
    throw new Error(`Logos must be 90 x 90 px PNG images (${logo})`)
  }

  await stat(logo)
  let newPath = `dist/logo.png`

  await exec(`cp ${logo} ${newPath}`)
  console.log('  COPIED LOGO:', newPath)
}

const copyImages = async (config, manifests) => {
  for (let manifestPath in manifests) {
    let manifest = manifests[manifestPath]
    let { name, icon } = manifest

    if (!icon) {
      continue
    }

    if (!name.match(/^[a-z_][a-z\d_]*$/i)) {
      throw new Error('Invalid component name')
    }

    let iconPath = path.join(path.dirname(manifestPath), icon)

    if (!iconPath.match(/\.png$/)) {
      throw new Error(`Icons must be 156 x 156 px PNG images (${iconPath})`)
    }

    await stat(iconPath)
    let newPath = `dist/icons/${name}.png`

    await exec(`cp ${iconPath} ${newPath}`)
    console.log('  COPIED ICON:', newPath)
  }
}

const prepareConfig = (config, manifests) => {
  let { components, ...rest } = config

  return {
    ...rest,
    components: getComponents(config, manifests),
  }
}

const getComponents = (config, manifests) => {
  let { components } = config

  let keys = [
    'name',
    'displayName',
    'componentType',
    'settingsURL',
    'settingsPanelHeight',
    'icon',
    'defaultWidth',
    'defaultHeight',
    'snappingRules',
    'props',
    'childComponents',
    'resizeX',
    'resizeY',
    'auth',
    'layout',
    'lockAspectRatio',
  ]

  return components.map(({ manifest }) => {
    return filterObject(manifests[manifest], keys)
  })
}

const loadJSON = async (path) => {
  let contents

  try {
    contents = await readFile(path)
  } catch (err) {
    throw new Error(`File missing: ${path}`)
  }

  try {
    return JSON.parse(contents)
  } catch (err) {
    throw new Error(`Error parsing file: ${path}`)
  }
}
