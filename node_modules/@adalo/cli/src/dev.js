const fs = require('fs')
const ChildProcess = require('child_process')
const util = require('util')
const path = require('path')
const os = require('os')
const webpack = require('webpack')
const WebpackDevServer = require('webpack-dev-server')
const request = require('request')
const portfinder = require('portfinder')
const io = require('socket.io-client')
const chalk = require('chalk')
const { filterObject } = require('./objects')
const { defaultConfig } = require('./webpackConfig')
const { migrate } = require('./utils/migrate')

const mkdir = async (path) => {
  const mkdir = util.promisify(fs.mkdir)
  const stat = util.promisify(fs.stat)

  try {
    let exists = await stat(path)

    if (exists) {
      return
    }
  } catch (err) {
    // Do nothing
  }

  await mkdir(path)
}

const showAuthError = () => {
  console.error(
    `
You are not signed in to Adalo!

To sign in, run:

  npx adalo login

`.red.bold
  )

  process.exit(1)
}

// Promisify
const readFile = util.promisify(fs.readFile)
const writeFile = util.promisify(fs.writeFile)
const stat = util.promisify(fs.stat)
const exec = util.promisify(ChildProcess.exec)
const requestPromise = util.promisify(request)

module.exports = async (args, opts) => {
  let SERVER = 'https://foundry-dev-server.herokuapp.com'
  if (opts.local) {
    SERVER =
      process.env.ADALO_DEV_SERVER ||
      process.env.FOUNDRY_DEV_SERVER ||
      'http://localhost:3035'
  }

  let authToken

  try {
    const rc = path.join(os.homedir(), '.adalorc')
    if (opts.local) {
      authToken = JSON.parse(fs.readFileSync(rc)).localAuthToken
    } else {
      authToken = JSON.parse(fs.readFileSync(rc)).productionAuthToken
    }
  } catch (err) {
    showAuthError()
  }

  const pkgPath = path.join(process.cwd(), 'package.json')
  const pkg = await loadJSON(pkgPath)
  const adaloConfigPath = path.join(process.cwd(), 'adalo.json')

  if (!fs.existsSync(adaloConfigPath)) {
    console.log(
      chalk.bold.yellow(
        '  New adalo.json does not exist, converting your project to use the new adalo.json...'
      )
    )
    console.log('')
    await migrate()
  }

  const adaloConfig = await loadJSON(adaloConfigPath)
  pkg.version = 'dev'
  const { name, version } = pkg

  const config = { ...adaloConfig, name, version }

  await mkdir('dist')
  await mkdir(path.join('dist', 'input'))

  let manifests = await getManifests(config.components)

  console.log('MANIFESTS:', JSON.stringify(manifests))

  const editorEntry = await buildEditorComponents(config, manifests, pkg.main)
  const runtimeEntry = await buildRuntimeComponents(config, manifests, pkg.main)

  console.log('Starting the dev web server...')

  const options = {
    publicPath: '/dist/',
    contentBase: '/dist',
    hot: false,
    inline: false,
    liveReload: true,
    stats: { colors: true },
  }

  let libraryName = ['protonLibraries', config.name, 'dev']
  let runtimeName = ['protonRuntime', config.name]

  const webpackConfig = await getWebpackConfig(
    libraryName,
    editorEntry,
    'dist/editor.js',
    config
  )

  let server = webpack(webpackConfig)
  server.hooks.afterCompile.tap('AfterCompilePlugin', () => {
    socket.emit('libraryUpdates', config.name)
  })
  server = new WebpackDevServer(server, options)

  const webpackConfig2 = await getWebpackConfig(
    runtimeName,
    runtimeEntry,
    'dist/runtime.js',
    config
  )
  const server2 = new WebpackDevServer(webpack(webpackConfig2), options)

  const port = await portfinder.getPortPromise()
  let listen = util.promisify(server.listen.bind(server))
  await listen(port, 'localhost')

  const port2 = await portfinder.getPortPromise()
  let listen2 = util.promisify(server2.listen.bind(server2))
  await listen2(port2, 'localhost')

  console.log(`STARTED LOCAL SERVERS: ${port}, ${port2}`)

  const socket = io(`${SERVER}/packager`, {
    query: {
      sessionToken: authToken,
      libraryName: config.name,
    },
  })

  socket.on('connect', () => {
    console.log(`[${new Date()}] Connected to server.`)
  })

  socket.on('disconnect', (reason) => {
    console.log(`[${new Date()}] Disconnected from server.`)

    if (reason === 'io server disconnect') {
      showAuthError()
    }
  })

  socket.on('request', async (type, callback) => {
    console.log('TYPE:', type)
    let url =
      type === 'runtime'
        ? `http://localhost:${port2}/dist/runtime.js`
        : `http://localhost:${port}/dist/editor.js`

    console.log('GETTING LOCAL BUILD:', url)

    request.get(url, (err, response, body) => {
      callback(body)
    })
  })
}

const getManifests = async (components) => {
  let manifests = {}

  for (let component of components) {
    let manifestPath = component.manifest
    let manifest = await loadJSON(manifestPath)
    manifest.name = component.name

    if (manifests[manifestPath]) {
      throw new Error(`Multiple components cannot share the same manifest file.
        \nBOTH USING: ${manifestPath}\n`)
    }

    manifests[manifestPath] = manifest
  }

  return manifests
}

const buildEditorComponents = async (config, manifests, entryPoint) => {
  let index = {}
  let imports = []

  for (let configItem of config.components) {
    let { name } = configItem

    if (!name.match(/^[a-z_][a-z\d_]*$/i)) {
      throw new Error(
        `Invalid component name: ${name} (in ${manifestPath})\n\n` +
          '////////////////////////////////////////////////////////////////\n' +
          '//\n' +
          '//  Please use camelCase or snake_case for component names.\n' +
          '//\n' +
          '//  Names can contain letters, numbers, and underscores (_),\n' +
          '//  but cannot start with a number.\n' +
          '//\n' +
          '////////////////////////////////////////////////////////////////\n\n'
      )
    }

    if (name in index) {
      throw new Error(
        `Component names must be unique (${name} in ${manifestPath})`
      )
    }

    imports.push(name)
    index[name] = true
  }

  let file = 'import {\n  '
  file += imports.join(',\n  ')
  file += `\n} from '../../${entryPoint}'\n\n`

  file += 'export const components = {\n  '
  file += imports.join(',\n  ')
  file += '\n}\n\n'
  file += `export const config = ${JSON.stringify(
    prepareConfig(config, manifests)
  )}`

  let inputFilename = './dist/input/editor.js'
  await writeFile(inputFilename, file)

  let libraryName = ['protonLibraries', config.name, config.version]
  //await pack(libraryName, inputFilename, outputFilename)
  //console.log('SUCCESSFULLY COMPILED EDITOR COMPONENTS.')

  return inputFilename
}

const buildRuntimeComponents = async (config, manifests, entryPoint) => {
  let imports = ['export {']

  for (let configItem of config.components) {
    let manifestPath = configItem.manifest
    let manifest = manifests[manifestPath]
    let importName = configItem.name

    // Expect this to be caught above.
    if (!manifest.name.match(/^[a-z_][a-z\d_]*$/i)) {
      throw new Error(`Invalid component name: ${manifest.name}`)
    }

    imports.push(`  ${importName} as ${manifest.name},`)
  }

  imports.push(`} from '../../${entryPoint}'`)

  let file = imports.join('\n')

  let inputFilename = './dist/input/runtime.js'
  let outputFilename = './dist/runtime.js'

  await writeFile(inputFilename, file)
  //await pack(['protonRuntime', config.name], inputFilename, outputFilename)
  //console.log('SUCCESSFULLY COMPILED RUNTIME.')
  return inputFilename
}

const buildMetadata = async (config, manifests) => {
  let result = {}

  for (let configItem of config.components) {
    let { name } = configItem
    let manifest = manifests[configItem.manifest]

    result[name] = manifest
  }

  await writeFile('./dist/metadata.json', JSON.stringify(result))
}

const getWebpackConfig = async (libraryPath, inputPath, outputPath, config) => {
  let outputDir = path.dirname(outputPath)
  let outputFilename = path.basename(outputPath)
  let preferredConfig = defaultConfig
  if (config.webpackConfig) {
    let { webpackConfig: webpackConfigFile } = config
    let webpackPath = path.join(process.cwd(), webpackConfigFile)
    if (!fs.existsSync(webpackPath)) {
      throw new Error(
        `Webpack config is specified in package.json, but the file does not exist!\n` +
          `File path: ${webpackPath}\n\n`
      )
    }
    let { default: webpackConfig } = await import(webpackPath)
    if (webpackConfig) preferredConfig = defaultConfig
  }

  return {
    ...preferredConfig,
    mode: 'development',
    entry: inputPath,
    output: {
      path: path.join(process.cwd(), outputDir),
      filename: outputFilename,
      library: libraryPath,
      libraryTarget: 'window',
    },
  }
}

// const copyImages = async (config, manifests) => {
//   for (let manifestPath in manifests) {
//     let manifest = manifests[manifestPath]
//     let { name, icon } = manifest
//
//     if (!icon) { continue }
//
//     if (!name.match(/^[a-z_][a-z\d_]*$/i)) {
//       throw new Error('Invalid component name')
//     }
//
//     let iconPath = path.join(path.dirname(manifestPath), icon)
//
//     if (!iconPath.match(/\.png$/)) {
//       throw new Error(`Icons must be 156 x 156 px PNG images (${iconPath})`)
//     }
//
//     await stat(iconPath)
//     let newPath = `dist/icons/${name}.png`
//
//     await exec(`cp ${iconPath} ${newPath}`)
//     console.log('COPIED ICON:', newPath)
//   }
// }

const prepareConfig = (config, manifests) => {
  let { components, ...rest } = config

  return {
    ...rest,
    components: getComponents(config, manifests),
  }
}

const getComponents = (config, manifests) => {
  let { components } = config

  let keys = [
    'name',
    'displayName',
    'componentType',
    'settingsURL',
    'settingsPanelHeight',
    'icon',
    'defaultWidth',
    'defaultHeight',
    'snappingRules',
    'props',
    'childComponents',
    'resizeX',
    'resizeY',
    'auth',
    'layout',
    'lockAspectRatio',
  ]

  return components.map(({ manifest }) => {
    return filterObject(manifests[manifest], keys)
  })
}

const loadJSON = async (path) => {
  let contents

  try {
    contents = await readFile(path)
  } catch (err) {
    throw new Error(`File missing: ${path}`)
  }

  try {
    return JSON.parse(contents)
  } catch (err) {
    throw new Error(`Error parsing file: ${path}`)
  }
}
